generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

model User {
  id                    String   @id @default(cuid())
  name                  String
  email                 String   @unique
  password              String
  businessName          String
  phone                 String?
  licenseNumber         String
  licenseState          String
  yearsExperience       String?
  selectedPlan          String   @default("pro")
  licenseFile           String?
  insuranceFile         String?
  hasActiveSubscription Boolean  @default(false)
  isLicenseVerified     Boolean  @default(false)
  role                  String   @default("artist")
  stripeId              String?  @unique
  stripeCustomerId      String?
  stripeSubscriptionId  String?
  subscriptionStatus    String   @default("inactive")
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  clients               Client[]
  appointments          Appointment[]
  services              Service[]
  procedures            Procedure[]
  consentForms          ConsentForm[]
  magicLinkTokens       MagicLinkToken[]
  metaConnections       MetaConnection[]
  calendarIntegrations  CalendarIntegration[]
  depositPayments       DepositPayment[]
  supportTickets        SupportTicket[]
  complaints            Complaint[]
  products              Product[]
  orders                Order[]

  @@map("users")
}

model Client {
  id                String      @id @default(cuid())
  userId            String
  name              String
  email             String?
  phone             String?
  dateOfBirth       DateTime?   // Client's date of birth
  emergencyContact  String?     // Emergency contact information
  medicalHistory    String?     // Medical history notes
  allergies         String?     // Known allergies
  skinType          String?     // Fitzpatrick skin type
  notes             String?
  isActive          Boolean     @default(true) // Whether client is still active
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  analyses   Analysis[]
  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  intakes    Intake[]
  photos     Photo[]
  documents  Document[]
  procedures Procedure[]
  appointments Appointment[]
  consentForms ConsentForm[]
  depositPayments DepositPayment[]
  orders Order[]

  @@map("clients")
}

model Photo {
  id        String     @id @default(cuid())
  clientId  String
  url       String
  filename  String?
  lighting  String?
  quality   String?
  createdAt DateTime   @default(now())
  analyses  Analysis[]
  client    Client     @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@map("photos")
}

model Intake {
  id           String   @id @default(cuid())
  clientId     String
  conditions   String
  medications  String
  notes        String?
  result       String?
  rationale    String?
  flaggedItems String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  client       Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@map("intakes")
}

model Analysis {
  id             String   @id @default(cuid())
  clientId       String
  photoId        String?
  fitzpatrick    Int?
  undertone      String?
  confidence     Float?
  recommendation Json?
  notes          String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  photo          Photo?   @relation(fields: [photoId], references: [id])
  client         Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@map("analyses")
}

model Pigment {
  id         String   @id @default(cuid())
  brand      String
  name       String
  baseTone   String
  hueNotes   String
  opacity    String
  idealFitz  String
  tempShift  String?
  useCase    String
  hexPreview String?
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([brand, name])
  @@map("pigments")
}

model MagicLinkToken {
  id        String   @id @default(cuid())
  userId    String
  email     String
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("magic_link_tokens")
}

model Document {
  id          String   @id @default(cuid())
  clientId    String
  type        DocumentType
  fileUrl     String
  filename    String?
  fileSize    Int?     // File size in bytes
  mimeType    String?  // MIME type of the file
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  client      Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@map("documents")
}

model Procedure {
  id                  String   @id @default(cuid())
  userId              String?
  clientId            String
  serviceId           String?
  appointmentId       String?
  procedureType       String   // Type of procedure (e.g., "Microblading", "Powder Brows", "Eyeliner")
  voltage             Float?   // Voltage used during procedure
  needleConfiguration String   // Needle configuration details
  needleSize          String?  // Needle size used
  pigmentBrand        String   // Brand of pigment used
  pigmentColor        String   // Color of pigment used
  lotNumber           String?  // Lot number of the pigment
  depth               String?  // Depth of pigment placement
  technique           String?  // Technique used
  duration            Int?     // Duration of procedure in minutes
  areaTreated         String?  // Specific area treated
  notes               String?  // Additional notes about the procedure
  beforePhotos        String?  // JSON string of before photo URLs
  afterPhotos         String?  // JSON string of after photo URLs
  healingProgress     String?  // Healing progress notes
  procedureDate       DateTime @default(now()) // When the procedure was performed
  followUpDate        DateTime? // Scheduled follow-up date
  touchUpScheduled    Boolean  @default(false) // Whether touch-up is scheduled
  touchUpDate         DateTime? // Touch-up appointment date
  isCompleted         Boolean  @default(false) // Whether procedure is completed
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  user                User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  client              Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  service             Service? @relation(fields: [serviceId], references: [id], onDelete: SetNull)
  appointment         Appointment? @relation(fields: [appointmentId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([clientId])
  @@index([procedureType])
  @@index([procedureDate])
  @@map("procedures")
}

enum DocumentType {
  ID_DOCUMENT
  CONSENT_FORM
  WAIVER
  INTAKE_FORM
  CONTRAINDICATION_FORM
  ANALYSIS_REPORT
  PHOTO
  OTHER
}

model MetaConnection {
  id                 String   @id @default(cuid())
  userId             String
  pageId             String
  pageName           String
  pageAccessToken    String
  pageTokenExpiresAt DateTime?
  igUserId           String?
  igUsername         String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, pageId])
  @@index([userId])
  @@map("meta_connections")
}

model CalendarIntegration {
  id                    String   @id @default(cuid())
  userId                String
  provider              CalendarProvider
  providerName          String   // e.g., "Calendly", "Acuity Scheduling"
  apiKey                String?  // API key or access token
  webhookUrl            String?  // Webhook URL for real-time sync
  calendarId            String?  // External calendar ID
  calendarName          String?  // External calendar name
  isActive              Boolean  @default(true)
  syncDirection         SyncDirection @default(BIDIRECTIONAL)
  lastSyncAt            DateTime?
  syncFrequency         Int      @default(15) // Minutes between syncs
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider, calendarId])
  @@index([userId])
  @@map("calendar_integrations")
}

enum CalendarProvider {
  CALENDLY
  ACUITY_SCHEDULING
  GOOGLE_CALENDAR
  OUTLOOK_CALENDAR
  BOOKLY
  SIMPLYBOOK_ME
  CUSTOM
}

enum SyncDirection {
  IMPORT_ONLY    // Only import from external calendar
  EXPORT_ONLY    // Only export to external calendar
  BIDIRECTIONAL  // Two-way sync
}

model DepositPayment {
  id                    String   @id @default(cuid())
  clientId             String
  appointmentId        String?  // Optional - can be created before appointment
  userId               String   // PMU Pro user (artist)
  amount               Decimal  // Deposit amount
  totalAmount          Decimal  // Total procedure cost
  remainingAmount      Decimal  // Amount due on procedure day
  currency             String   @default("USD")
  status               DepositStatus @default(PENDING)
  paymentMethod        String?  // Stripe payment method ID
  stripePaymentIntentId String? // Stripe payment intent ID
  stripeSessionId      String?  // Stripe checkout session ID
  depositLink          String   @unique // Unique link for client to pay
  depositLinkExpiresAt DateTime // Link expiration
  paidAt               DateTime?
  refundedAt           DateTime?
  refundAmount         Decimal?
  refundReason         String?
  notes                String?  // Additional notes
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  client               Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([userId])
  @@index([depositLink])
  @@index([status])
  @@map("deposit_payments")
}

enum DepositStatus {
  PENDING     // Deposit link created, awaiting payment
  PAID        // Deposit paid successfully
  EXPIRED     // Deposit link expired
  REFUNDED    // Deposit refunded
  CANCELLED   // Deposit cancelled
}

model DataDeletionRequest {
  id          String   @id @default(cuid())
  email       String
  reason      String?
  status      DeletionStatus @default(PENDING)
  requestedAt DateTime @default(now())
  completedAt DateTime?
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([email])
  @@index([status])
  @@map("data_deletion_requests")
}

enum DeletionStatus {
  PENDING     // Request submitted, awaiting processing
  PROCESSING  // Request is being processed
  COMPLETED   // Data deletion completed
  FAILED      // Deletion failed, manual review required
}

model MarketingConnection {
  id            String   @id @default(cuid())
  userId        String
  platform      String   // 'google' | 'meta'
  accountId     String?  // e.g. Google customer ID or Meta ad account ID
  accountName   String?
  accessToken   String   // encrypted
  refreshToken  String?  // encrypted
  tokenMetaJson String?  // encrypted JSON (expiry, scopes)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([userId, platform])
  @@index([userId])
  @@map("marketing_connections")
}

model MarketingLead {
  id        String   @id @default(cuid())
  email     String
  name      String?
  phone     String?
  company   String?
  plan      String   // 'self_serve' | 'optimized'
  notes     String?
  source    String   @default("website") // 'website' | 'google' | 'meta' | 'referral'
  status    String   @default("new") // 'new' | 'contacted' | 'qualified' | 'converted' | 'lost'
  createdAt DateTime @default(now())

  @@index([email])
  @@index([status])
  @@index([source])
  @@map("marketing_leads")
}

model MarketingSync {
  id        String   @id @default(cuid())
  platform  String   // 'meta' | 'google' | 'both'
  status    String   // 'configured' | 'syncing' | 'completed' | 'failed'
  lastSync  DateTime
  notes     String?
  createdAt DateTime @default(now())

  @@index([platform])
  @@index([status])
  @@map("marketing_syncs")
}

model Appointment {
  id             String    @id @default(cuid())
  userId         String
  clientId       String
  title          String
  serviceType    String
  duration       Int       // Duration in minutes
  startTime      DateTime
  endTime        DateTime
  status         String    @default("scheduled") // scheduled, confirmed, completed, cancelled, no-show
  price          Float?
  deposit        Float?
  paymentStatus  String    @default("pending") // pending, partial, paid, refunded
  source         String    @default("booking") // booking, manual, client_management
  bookingUrl     String?
  notes          String?
  reminderSent   Boolean   @default(false)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  client  Client  @relation(fields: [clientId], references: [id], onDelete: Cascade)
  procedures Procedure[]

  @@index([userId])
  @@index([clientId])
  @@index([startTime])
  @@index([status])
  @@map("appointments")
}

model Service {
  id              String   @id @default(cuid())
  userId          String
  name            String
  description     String?
  defaultDuration Int      // in minutes
  defaultPrice    Float
  category        String   // eyebrows, lips, eyeliner, consultation, touch-up, other
  isActive        Boolean  @default(true)
  imageUrl        String?  // URL for service icon/image
  isCustomImage   Boolean  @default(false) // Whether image was uploaded by user
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  procedures Procedure[]

  @@index([userId])
  @@index([category])
  @@index([isActive])
  @@map("services")
}


model ConsentForm {
  id                    String   @id @default(cuid())
  userId                String?
  clientId              String
  procedureType         String   // Type of procedure
  clientSignature       String   // Base64 signature data
  clientSignatureDate   DateTime @default(now())
  artistSignature       String   // Artist signature
  artistSignatureDate   DateTime @default(now())
  medicalHistory        String?  // Medical history disclosed
  allergies             String?  // Allergies disclosed
  medications           String?  // Current medications
  skinConditions        String?  // Skin conditions
  previousProcedures    String?  // Previous PMU procedures
  consentGiven          Boolean  @default(true)
  photographyConsent    Boolean  @default(false)
  marketingConsent      Boolean  @default(false)
  emergencyContact      String?  // Emergency contact info
  additionalNotes       String?  // Any additional notes
  formVersion           String   @default("1.0")
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  client Client  @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([clientId])
  @@index([procedureType])
  @@index([createdAt])
  @@map("consent_forms")
}

model SupportTicket {
  id          String   @id @default(cuid())
  title       String
  description String
  status      String   @default("open") // open, in_progress, resolved, closed
  priority    String   @default("medium") // low, medium, high, urgent
  category    String   @default("general") // general, technical, billing, feature_request
  userId      String?  // User who created the ticket
  createdBy   String   // Email of person who created the ticket
  assignedTo  String?  // Staff member assigned to the ticket
  resolution  String?  // Resolution notes
  notes       String?  // Additional notes
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([status])
  @@index([priority])
  @@index([createdBy])
  @@index([assignedTo])
  @@map("support_tickets")
}

model Complaint {
  id          String   @id @default(cuid())
  subject     String
  description String
  status      String   @default("new") // new, investigating, resolved, closed
  priority    String   @default("medium") // low, medium, high, urgent
  category    String   @default("general") // general, technical, billing, service
  userId      String?  // User who reported the complaint
  reportedBy  String   // Email of person who reported the complaint
  assignedTo  String?  // Staff member assigned to the complaint
  resolution  String?  // Resolution notes
  notes       String?  // Additional notes
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([status])
  @@index([priority])
  @@index([reportedBy])
  @@index([assignedTo])
  @@map("complaints")
}

model InventoryItem {
  id           String   @id @default(cuid())
  name         String
  category     String   // Tools, Pigments, Consumables, Anesthetics, Aftercare
  brand        String?
  sku          String?  // Stock Keeping Unit
  currentStock Int      @default(0)
  minStock     Int?     // Minimum stock level
  maxStock     Int?     // Maximum stock level
  unitCost     Float    @default(0)
  totalValue   Float    @default(0) // currentStock * unitCost
  status       String   @default("in_stock") // in_stock, low_stock, out_of_stock
  description  String?
  location     String?  // Storage location
  supplier     String?  // Supplier information
  lastUpdated  DateTime @default(now())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([category])
  @@index([status])
  @@index([brand])
  @@map("inventory_items")
}

model Meta {
  key   String @id
  value String

  @@map("meta")
}

enum FulfillmentMethod {
  pickup
  delivery
  shipping
}

enum OrderStatus {
  pending
  confirmed
  processing
  shipped
  delivered
  cancelled
}

model Product {
  id            String   @id @default(cuid())
  userId        String
  name          String
  description   String?
  price         Float
  category      String?
  sku           String?
  stockQuantity Int      @default(0)
  isDigital     Boolean  @default(false)
  images        String   @default("[]")
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  orderItems OrderItem[]

  @@index([userId])
  @@index([category])
  @@index([isActive])
  @@map("products")
}

model Order {
  id                String           @id @default(cuid())
  userId            String
  clientId          String?
  clientEmail       String?
  clientName        String?
  clientPhone       String?
  totalAmount       Float
  fulfillmentMethod String           @default("pickup")
  shippingAddress   String?
  status            String           @default("pending")
  notes             String?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  client     Client?     @relation(fields: [clientId], references: [id], onDelete: SetNull)
  orderItems OrderItem[]

  @@index([userId])
  @@index([status])
  @@map("orders")
}

model OrderItem {
  id        String  @id @default(cuid())
  orderId   String
  productId String
  quantity  Int
  price     Float
  createdAt DateTime @default(now())

  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([productId])
  @@map("order_items")
}
