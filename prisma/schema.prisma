generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("NEON_DATABASE_URL")
}

model User {
  id                    String   @id @default(cuid())
  name                  String
  email                 String   @unique
  password              String
  businessName          String
  phone                 String?
  licenseNumber         String
  licenseState          String
  yearsExperience       String?
  selectedPlan          String   @default("pro")
  licenseFile           String?
  insuranceFile         String?
  hasActiveSubscription Boolean  @default(false)
  isLicenseVerified     Boolean  @default(false)
  role                  String   @default("artist")
  stripeId              String?  @unique
  stripeCustomerId      String?
  stripeSubscriptionId  String?
  subscriptionStatus    String   @default("inactive")
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  clients               Client[]
  magicLinkTokens       MagicLinkToken[]
  metaConnections       MetaConnection[]
  calendarIntegrations  CalendarIntegration[]

  @@map("users")
}

model Client {
  id                String      @id @default(cuid())
  userId            String
  name              String
  email             String?
  phone             String?
  dateOfBirth       DateTime?   // Client's date of birth
  emergencyContact  String?     // Emergency contact information
  medicalHistory    String?     // Medical history notes
  allergies         String?     // Known allergies
  skinType          String?     // Fitzpatrick skin type
  notes             String?
  isActive          Boolean     @default(true) // Whether client is still active
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  analyses   Analysis[]
  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  intakes    Intake[]
  photos     Photo[]
  documents  Document[]
  procedures Procedure[]

  @@map("clients")
}

model Photo {
  id        String     @id @default(cuid())
  clientId  String
  url       String
  filename  String?
  lighting  String?
  quality   String?
  createdAt DateTime   @default(now())
  analyses  Analysis[]
  client    Client     @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@map("photos")
}

model Intake {
  id           String   @id @default(cuid())
  clientId     String
  conditions   String
  medications  String
  notes        String?
  result       String?
  rationale    String?
  flaggedItems String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  client       Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@map("intakes")
}

model Analysis {
  id             String   @id @default(cuid())
  clientId       String
  photoId        String?
  fitzpatrick    Int?
  undertone      String?
  confidence     Float?
  recommendation Json?
  notes          String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  photo          Photo?   @relation(fields: [photoId], references: [id])
  client         Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@map("analyses")
}

model Pigment {
  id         String   @id @default(cuid())
  brand      String
  name       String
  baseTone   String
  hueNotes   String
  opacity    String
  idealFitz  String
  tempShift  String?
  useCase    String
  hexPreview String?
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([brand, name])
  @@map("pigments")
}

model MagicLinkToken {
  id        String   @id @default(cuid())
  userId    String
  email     String
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("magic_link_tokens")
}

model Document {
  id          String   @id @default(cuid())
  clientId    String
  type        DocumentType
  fileUrl     String
  filename    String?
  fileSize    Int?     // File size in bytes
  mimeType    String?  // MIME type of the file
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  client      Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@map("documents")
}

model Procedure {
  id                  String   @id @default(cuid())
  clientId            String
  procedureType       String   // Type of procedure (e.g., "Microblading", "Powder Brows", "Eyeliner")
  voltage             Float    // Voltage used during procedure
  needleConfiguration String   // Needle configuration details
  pigmentBrand        String   // Brand of pigment used
  pigmentColor        String   // Color of pigment used
  lotNumber           String   // Lot number of the pigment
  depth               String?  // Depth of pigment placement
  duration            Int?     // Duration of procedure in minutes
  areaTreated         String?  // Specific area treated
  notes               String?  // Additional notes about the procedure
  procedureDate       DateTime // When the procedure was performed
  followUpDate        DateTime? // Scheduled follow-up date
  isCompleted         Boolean  @default(false) // Whether procedure is completed
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  client              Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@map("procedures")
}

enum DocumentType {
  ID_DOCUMENT
  CONSENT_FORM
  WAIVER
  INTAKE_FORM
  CONTRAINDICATION_FORM
  ANALYSIS_REPORT
  PHOTO
  OTHER
}

model MetaConnection {
  id                 String   @id @default(cuid())
  userId             String
  pageId             String
  pageName           String
  pageAccessToken    String
  pageTokenExpiresAt DateTime?
  igUserId           String?
  igUsername         String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, pageId])
  @@index([userId])
  @@map("meta_connections")
}

model CalendarIntegration {
  id                    String   @id @default(cuid())
  userId                String
  provider              CalendarProvider
  providerName          String   // e.g., "Calendly", "Acuity Scheduling"
  apiKey                String?  // API key or access token
  webhookUrl            String?  // Webhook URL for real-time sync
  calendarId            String?  // External calendar ID
  calendarName          String?  // External calendar name
  isActive              Boolean  @default(true)
  syncDirection         SyncDirection @default(BIDIRECTIONAL)
  lastSyncAt            DateTime?
  syncFrequency         Int      @default(15) // Minutes between syncs
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider, calendarId])
  @@index([userId])
  @@map("calendar_integrations")
}

enum CalendarProvider {
  CALENDLY
  ACUITY_SCHEDULING
  GOOGLE_CALENDAR
  OUTLOOK_CALENDAR
  BOOKLY
  SIMPLYBOOK_ME
  CUSTOM
}

enum SyncDirection {
  IMPORT_ONLY    // Only import from external calendar
  EXPORT_ONLY    // Only export to external calendar
  BIDIRECTIONAL  // Two-way sync
}
